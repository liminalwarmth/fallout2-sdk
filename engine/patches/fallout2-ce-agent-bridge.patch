diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5e03941..c2bc37c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -21,6 +21,7 @@ set(CMAKE_CXX_STANDARD_REQUIRED YES)
 set(CMAKE_CXX_EXTENSIONS NO)
 
 option(FALLOUT_VENDORED "Use vendored third-party libraries" ON)
+option(AGENT_BRIDGE "Enable file-based agent bridge" OFF)
 
 if(ANDROID)
     add_library(${EXECUTABLE_NAME} SHARED)
@@ -375,6 +376,26 @@ target_include_directories(${EXECUTABLE_NAME} PRIVATE ${ZLIB_INCLUDE_DIRS})
 target_link_libraries(${EXECUTABLE_NAME} ${SDL2_LIBRARIES})
 target_include_directories(${EXECUTABLE_NAME} PRIVATE ${SDL2_INCLUDE_DIRS})
 
+if(AGENT_BRIDGE)
+    include(FetchContent)
+    FetchContent_Declare(
+        nlohmann_json
+        URL https://github.com/nlohmann/json/releases/download/v3.11.3/json.tar.xz
+    )
+    FetchContent_MakeAvailable(nlohmann_json)
+
+    target_compile_definitions(${EXECUTABLE_NAME} PUBLIC AGENT_BRIDGE)
+    target_sources(${EXECUTABLE_NAME} PRIVATE
+        "../../src/agent_bridge.h"
+        "../../src/agent_bridge_internal.h"
+        "../../src/agent_bridge.cc"
+        "../../src/agent_state.cc"
+        "../../src/agent_commands.cc"
+    )
+    target_include_directories(${EXECUTABLE_NAME} PRIVATE ../../src ${CMAKE_CURRENT_SOURCE_DIR}/src)
+    target_link_libraries(${EXECUTABLE_NAME} nlohmann_json::nlohmann_json)
+endif()
+
 if(APPLE)
     if(IOS)
         install(TARGETS ${EXECUTABLE_NAME} DESTINATION "Payload")
diff --git a/src/animation.cc b/src/animation.cc
index 0884eb2..363f81b 100644
--- a/src/animation.cc
+++ b/src/animation.cc
@@ -305,7 +305,7 @@ static bool _anim_in_bk = false;
 static AnimationSad gAnimationSads[ANIMATION_SAD_LIST_CAPACITY];
 
 // 0x542FD4
-static PathNode gClosedPathNodeList[2000];
+static PathNode gClosedPathNodeList[8000];
 
 // 0x54CC14
 static AnimationSequence gAnimationSequences[32];
@@ -314,7 +314,7 @@ static AnimationSequence gAnimationSequences[32];
 static unsigned char gPathfinderProcessedTiles[5000];
 
 // 0x562B9C
-static PathNode gOpenPathNodeList[2000];
+static PathNode gOpenPathNodeList[8000];
 
 // 0x56C7DC
 static int gAnimationDescriptionCurrentIndex;
@@ -1740,7 +1740,7 @@ int pathfinderFindPath(Object* object, int from, int to, unsigned char* rotation
     gOpenPathNodeList[0].estimate = _tile_idistance(from, to);
     gOpenPathNodeList[0].cost = 0;
 
-    for (int index = 1; index < 2000; index += 1) {
+    for (int index = 1; index < 8000; index += 1) {
         gOpenPathNodeList[index].tile = -1;
     }
 
@@ -1788,7 +1788,7 @@ int pathfinderFindPath(Object* object, int from, int to, unsigned char* rotation
 
         closedPathNodeListLength += 1;
 
-        if (closedPathNodeListLength == 2000) {
+        if (closedPathNodeListLength == 8000) {
             return 0;
         }
 
@@ -1809,7 +1809,7 @@ int pathfinderFindPath(Object* object, int from, int to, unsigned char* rotation
             }
 
             int v25 = 0;
-            for (; v25 < 2000; v25++) {
+            for (; v25 < 8000; v25++) {
                 if (gOpenPathNodeList[v25].tile == -1) {
                     break;
                 }
@@ -1817,7 +1817,7 @@ int pathfinderFindPath(Object* object, int from, int to, unsigned char* rotation
 
             openPathNodeListLength += 1;
 
-            if (openPathNodeListLength == 2000) {
+            if (openPathNodeListLength == 8000) {
                 return 0;
             }
 
@@ -1866,7 +1866,7 @@ int pathfinderFindPath(Object* object, int from, int to, unsigned char* rotation
     if (openPathNodeListLength != 0) {
         unsigned char* v39 = rotations;
         int index = 0;
-        for (; index < 800; index++) {
+        for (; index < 2000; index++) {
             if (temp.tile == from) {
                 break;
             }
diff --git a/src/character_editor.cc b/src/character_editor.cc
index 0d989a7..9e5c730 100644
--- a/src/character_editor.cc
+++ b/src/character_editor.cc
@@ -8,6 +8,10 @@
 #include <algorithm>
 #include <vector>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "art.h"
 #include "color.h"
 #include "combat.h"
@@ -754,19 +758,19 @@ static int gCharacterEditorOptionalTraitsBackup[3];
 // current index for selecting new trait
 //
 // 0x5709FC
-static int gCharacterEditorTempTraitCount;
+int gCharacterEditorTempTraitCount;
 
 // 0x570A00
 static int gPerkDialogOptionCount;
 
 // 0x570A04
-static int gCharacterEditorTempTraits[3];
+int gCharacterEditorTempTraits[3];
 
 // 0x570A10
-static int gCharacterEditorTaggedSkillCount;
+int gCharacterEditorTaggedSkillCount;
 
 // 0x570A14
-static int gCharacterEditorTempTaggedSkills[NUM_TAGGED_SKILLS];
+int gCharacterEditorTempTaggedSkills[NUM_TAGGED_SKILLS];
 
 // 0x570A28
 static char gCharacterEditorHasFreePerkBackup;
@@ -808,6 +812,10 @@ int characterEditorShow(bool isCreationMode)
         return -1;
     }
 
+#ifdef AGENT_BRIDGE
+    agentBridgeSetContext(AGENT_CONTEXT_CHAR_EDITOR);
+#endif
+
     if (!gCharacterEditorIsCreationMode) {
         if (characterEditorUpdateLevel()) {
             critterUpdateDerivedStats(gDude);
@@ -7303,4 +7311,36 @@ static void customTownReputationFree()
     gCustomTownReputationEntries.clear();
 }
 
+// --- Agent bridge accessor functions ---
+
+int agentEditorGetCurrentSkill()
+{
+    return gCharacterEditorCurrentSkill;
+}
+
+void agentEditorSetCurrentSkill(int skill)
+{
+    gCharacterEditorCurrentSkill = skill;
+}
+
+bool agentEditorHasFreePerk()
+{
+    return gCharacterEditorHasFreePerk != 0;
+}
+
+int agentEditorSelectPerk(int perkId)
+{
+    for (int i = 0; i < DIALOG_PICKER_NUM_OPTIONS; i++) {
+        if (gPerkDialogOptionList[i].name == nullptr)
+            break;
+        if (gPerkDialogOptionList[i].value == perkId) {
+            gPerkDialogTopLine = i;
+            gPerkDialogCurrentLine = 0;
+            enqueueInputEvent(KEY_RETURN);
+            return 0;
+        }
+    }
+    return -1; // perk not found in available list
+}
+
 } // namespace fallout
diff --git a/src/character_editor.h b/src/character_editor.h
index af69e84..00d19f1 100644
--- a/src/character_editor.h
+++ b/src/character_editor.h
@@ -6,6 +6,10 @@
 namespace fallout {
 
 extern int gCharacterEditorRemainingCharacterPoints;
+extern int gCharacterEditorTaggedSkillCount;
+extern int gCharacterEditorTempTraitCount;
+extern int gCharacterEditorTempTraits[3];
+extern int gCharacterEditorTempTaggedSkills[4];
 
 int characterEditorShow(bool isCreationMode);
 void characterEditorInit();
@@ -15,6 +19,12 @@ int characterEditorSave(File* stream);
 int characterEditorLoad(File* stream);
 void characterEditorReset();
 
+// Agent bridge: character editor accessors
+int agentEditorGetCurrentSkill();
+void agentEditorSetCurrentSkill(int skill);
+bool agentEditorHasFreePerk();
+int agentEditorSelectPerk(int perkId);
+
 } // namespace fallout
 
 #endif /* CHARACTER_EDITOR_H */
diff --git a/src/character_selector.cc b/src/character_selector.cc
index 76d3ea4..e6ddb9e 100644
--- a/src/character_selector.cc
+++ b/src/character_selector.cc
@@ -6,6 +6,10 @@
 #include <algorithm>
 #include <vector>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "art.h"
 #include "character_editor.h"
 #include "color.h"
@@ -152,6 +156,10 @@ int characterSelectorOpen()
         return 0;
     }
 
+#ifdef AGENT_BRIDGE
+    agentBridgeSetContext(AGENT_CONTEXT_CHAR_SELECTOR);
+#endif
+
     bool cursorWasHidden = cursorIsHidden();
     if (cursorWasHidden) {
         mouseShowCursor();
diff --git a/src/combat.cc b/src/combat.cc
index 825a573..4b13e1c 100644
--- a/src/combat.cc
+++ b/src/combat.cc
@@ -9,6 +9,9 @@
 #include "art.h"
 #include "color.h"
 #include "combat_ai.h"
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
 #include "critter.h"
 #include "db.h"
 #include "debug.h"
@@ -3226,6 +3229,11 @@ static int _combat_turn(Object* obj, bool a2)
 {
     _combat_turn_obj = obj;
 
+    // Center camera on the acting combatant so the player can see each turn
+    if (obj->elevation == gDude->elevation) {
+        tileSetCenter(obj->tile, TILE_SET_CENTER_REFRESH_WINDOW);
+    }
+
     attackInit(&_main_ctd, obj, nullptr, HIT_MODE_PUNCH, HIT_LOCATION_TORSO);
 
     if ((obj->data.critter.combat.results & (DAM_KNOCKED_OUT | DAM_DEAD | DAM_LOSE_TURN)) != 0) {
@@ -3282,7 +3290,20 @@ static int _combat_turn(Object* obj, bool a2)
                     _combat_outline_on();
                 }
 
+#ifdef AGENT_BRIDGE
+                if (gAgentAutoCombat) {
+                    // Engine AI drives player's turn — grant free-move AP
+                    // so the AI benefits from Bonus Move perk
+                    gDude->data.critter.combat.ap += _combat_free_move;
+                    _combat_free_move = 0;
+
+                    Object* aiTarget = _gcsd != nullptr ? _gcsd->defender : nullptr;
+                    _combat_ai(gDude, aiTarget);
+                    // Falls through to _combat_turn_run() and normal cleanup
+                } else if (_combat_input() == -1) {
+#else
                 if (_combat_input() == -1) {
+#endif
                     gameUiDisable(1);
                     gameMouseSetCursor(MOUSE_CURSOR_WAIT_WATCH);
                     obj->data.critter.combat.damageLastTurn = 0;
@@ -6842,4 +6863,22 @@ Attack* combat_get_data()
     return &_main_ctd;
 }
 
+// Agent bridge accessors for combat turn order
+int agentGetCombatantCount()
+{
+    return _list_total;
+}
+
+Object* agentGetCombatant(int index)
+{
+    if (index < 0 || index >= _list_total || _combat_list == nullptr)
+        return nullptr;
+    return _combat_list[index];
+}
+
+int agentGetCurrentCombatantIndex()
+{
+    return _list_com;
+}
+
 } // namespace fallout
diff --git a/src/combat.h b/src/combat.h
index 7935844..1c62a27 100644
--- a/src/combat.h
+++ b/src/combat.h
@@ -76,6 +76,11 @@ void combat_set_hit_location_penalty(int hit_location, int penalty);
 void combat_reset_hit_location_penalty();
 Attack* combat_get_data();
 
+// Agent bridge accessors for combat turn order
+int agentGetCombatantCount();
+Object* agentGetCombatant(int index);
+int agentGetCurrentCombatantIndex();
+
 static inline bool isInCombat()
 {
     return (gCombatState & COMBAT_STATE_0x01) != 0;
diff --git a/src/combat_ai.cc b/src/combat_ai.cc
index 5d7dd0f..61fee3a 100644
--- a/src/combat_ai.cc
+++ b/src/combat_ai.cc
@@ -2720,7 +2720,7 @@ static int _ai_try_attack(Object* attacker, Object* defender)
         _ai_switch_weapons(attacker, &hitMode, &weapon, defender);
     }
 
-    unsigned char rotations[800];
+    unsigned char rotations[2000];
 
     Object* ammo = nullptr;
     for (int attempt = 0; attempt < 10; attempt++) {
diff --git a/src/display_monitor.cc b/src/display_monitor.cc
index 977c029..2ec610b 100644
--- a/src/display_monitor.cc
+++ b/src/display_monitor.cc
@@ -482,4 +482,21 @@ static void consoleFileFlush()
     }
 }
 
+// Agent bridge accessors — read recent messages from the circular buffer
+int agentDisplayMonitorGetLineCount()
+{
+    return gDisplayMonitorLinesCapacity;
+}
+
+const char* agentDisplayMonitorGetLine(int index)
+{
+    // Index 0 = most recent line, 1 = second most recent, etc.
+    // _disp_start points to the next insertion slot (one past latest)
+    if (index < 0 || index >= gDisplayMonitorLinesCapacity) {
+        return nullptr;
+    }
+    int actualIndex = (gDisplayMonitorLinesCapacity + _disp_start - 1 - index) % gDisplayMonitorLinesCapacity;
+    return gDisplayMonitorLines[actualIndex];
+}
+
 } // namespace fallout
diff --git a/src/display_monitor.h b/src/display_monitor.h
index 39d5a19..011705e 100644
--- a/src/display_monitor.h
+++ b/src/display_monitor.h
@@ -10,6 +10,10 @@ void displayMonitorAddMessage(char* string);
 void displayMonitorDisable();
 void displayMonitorEnable();
 
+// Agent bridge accessors for message log
+int agentDisplayMonitorGetLineCount();
+const char* agentDisplayMonitorGetLine(int index);
+
 } // namespace fallout
 
 #endif /* DISPLAY_MONITOR_H */
diff --git a/src/game.cc b/src/game.cc
index 978a385..5758bd9 100644
--- a/src/game.cc
+++ b/src/game.cc
@@ -3,6 +3,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "actions.h"
 #include "animation.h"
 #include "art.h"
@@ -381,6 +385,10 @@ int gameInitWithOptions(const char* windowTitle, bool isMapper, int font, int a4
 
     messageListRepositorySetStandardMessageList(STANDARD_MESSAGE_LIST_MISC, &gMiscMessageList);
 
+#ifdef AGENT_BRIDGE
+    agentBridgeInit();
+#endif
+
     return 0;
 }
 
@@ -435,6 +443,10 @@ void gameExit()
 {
     debugPrint("\nGame Exit\n");
 
+#ifdef AGENT_BRIDGE
+    agentBridgeExit();
+#endif
+
     // SFALL
     sfall_gl_scr_exit();
     sfallArraysExit();
diff --git a/src/game_dialog.cc b/src/game_dialog.cc
index ff98814..d59c77a 100644
--- a/src/game_dialog.cc
+++ b/src/game_dialog.cc
@@ -42,6 +42,17 @@
 #include "tile.h"
 #include "window_manager.h"
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+// Wrapper: redraw dialogue thought overlay before presenting each frame,
+// so it stays on top of talking head animations and window refreshes.
+#define DIALOG_RENDER_PRESENT() do { agentRedrawDialogueOverlay(); renderPresent(); } while(0)
+#else
+#define DIALOG_RENDER_PRESENT() renderPresent()
+#endif
+// NOTE: All renderPresent() calls in this file are replaced with
+// DIALOG_RENDER_PRESENT() to keep the dialogue overlay on top.
+
 namespace fallout {
 
 #define DIALOG_REVIEW_ENTRIES_CAPACITY 80
@@ -668,6 +679,50 @@ bool _gdialogActive()
     return _dialog_state_fix != 0;
 }
 
+int agentGetDialogOptionCount()
+{
+    return gGameDialogOptionEntriesLength;
+}
+
+const char* agentGetDialogOptionText(int index)
+{
+    if (index < 0 || index >= gGameDialogOptionEntriesLength)
+        return nullptr;
+    return gDialogOptionEntries[index].text;
+}
+
+const char* agentGetDialogReplyText()
+{
+    return gDialogReplyText;
+}
+
+Object* agentGetBarterPlayerTable()
+{
+    return _peon_table_obj;
+}
+
+Object* agentGetBarterMerchantTable()
+{
+    return _barterer_table_obj;
+}
+
+int agentGetBarterModifier()
+{
+    return gGameDialogBarterModifier;
+}
+
+void agentDialogHighlightOption(int index)
+{
+    if (index < 0 || index >= gGameDialogOptionEntriesLength)
+        return;
+    gameDialogOptionOnMouseEnter(index);
+}
+
+bool agentDialogIsTalkingHead()
+{
+    return gGameDialogHeadFid != -1;
+}
+
 // gdialogEnter
 // 0x444D3C
 void gameDialogEnter(Object* speaker, int a2)
@@ -1497,7 +1552,7 @@ int gameDialogShowReview()
             }
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 
@@ -2005,7 +2060,7 @@ int _gdProcess()
             }
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 
@@ -2574,7 +2629,7 @@ void gameDialogWaitForFidgetToComplete()
             gGameDialogFidgetFrmCurrentFrame++;
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 
@@ -2625,7 +2680,7 @@ void _gdPlayTransition(int anim)
             frame++;
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 
@@ -2975,7 +3030,7 @@ void _gdialog_scroll_subwin(int windowIdx, bool scrollUp, unsigned char* windowF
 
             delay_ms(33);
 
-            renderPresent();
+            DIALOG_RENDER_PRESENT();
             sharedFpsLimiter.throttle();
         }
     } else {
@@ -3013,7 +3068,7 @@ void _gdialog_scroll_subwin(int windowIdx, bool scrollUp, unsigned char* windowF
 
             delay_ms(33);
 
-            renderPresent();
+            DIALOG_RENDER_PRESENT();
             sharedFpsLimiter.throttle();
         }
     }
@@ -3775,7 +3830,7 @@ void partyMemberControlWindowHandleEvents()
             }
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 }
@@ -3972,7 +4027,7 @@ void partyMemberCustomizationWindowHandleEvents()
             }
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 }
@@ -4234,7 +4289,7 @@ int _gdCustomSelect(int a1)
             }
         }
 
-        renderPresent();
+        DIALOG_RENDER_PRESENT();
         sharedFpsLimiter.throttle();
     }
 
diff --git a/src/game_dialog.h b/src/game_dialog.h
index 0dccf6b..c38fda0 100644
--- a/src/game_dialog.h
+++ b/src/game_dialog.h
@@ -39,6 +39,20 @@ void gameDialogSetBarterModifier(int modifier);
 int gameDialogBarter(int modifier);
 void _barter_end_to_talk_to();
 
+// Agent bridge accessors for dialogue state
+int agentGetDialogOptionCount();
+const char* agentGetDialogOptionText(int index);
+const char* agentGetDialogReplyText();
+
+// Agent bridge accessors for barter state
+Object* agentGetBarterPlayerTable();
+Object* agentGetBarterMerchantTable();
+int agentGetBarterModifier();
+
+// Agent bridge accessors for dialogue UI
+void agentDialogHighlightOption(int index);
+bool agentDialogIsTalkingHead();
+
 } // namespace fallout
 
 #endif /* GAME_DIALOG_H */
diff --git a/src/game_movie.cc b/src/game_movie.cc
index 29a63de..ddb766a 100644
--- a/src/game_movie.cc
+++ b/src/game_movie.cc
@@ -3,6 +3,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "color.h"
 #include "cycle.h"
 #include "debug.h"
@@ -250,6 +254,14 @@ int gameMoviePlay(int movie, int flags)
             break;
         }
 
+#ifdef AGENT_BRIDGE
+        // Check if the agent has requested a skip via agent_cmd.json
+        // (agentBridgeTick doesn't run during movie playback)
+        if (agentBridgeCheckMovieSkip()) {
+            break;
+        }
+#endif
+
         Gesture gesture;
         if (touch_get_gesture(&gesture) && gesture.state == kEnded) {
             break;
diff --git a/src/input.cc b/src/input.cc
index 33acd6e..fec2702 100644
--- a/src/input.cc
+++ b/src/input.cc
@@ -156,9 +156,17 @@ int inputGetInput()
 
     _GNW95_process_message();
 
+#ifdef AGENT_BRIDGE
+    // When agent bridge is active, don't pause on focus loss.
+    // The agent needs the game loop to keep running in the background.
+    if (!gProgramIsActive) {
+        _GNW95_process_message();
+    }
+#else
     if (!gProgramIsActive) {
         _GNW95_lost_focus();
     }
+#endif
 
     _process_bk();
 
diff --git a/src/inventory.cc b/src/inventory.cc
index 7afc8cf..3235051 100644
--- a/src/inventory.cc
+++ b/src/inventory.cc
@@ -5970,6 +5970,16 @@ static int inventoryQuantityWindowFree(int inventoryWindowType)
 // 0x477074
 int _inven_set_timer(Object* item)
 {
+#ifdef AGENT_BRIDGE
+    // Agent bridge: accept pre-set timer to avoid blocking dialog
+    extern int gAgentPendingExplosiveTimer;
+    if (gAgentPendingExplosiveTimer > 0) {
+        int result = gAgentPendingExplosiveTimer;
+        gAgentPendingExplosiveTimer = 0;
+        return result;
+    }
+#endif
+
     bool isInitialized = _inven_is_initialized;
 
     if (!isInitialized) {
diff --git a/src/loadsave.cc b/src/loadsave.cc
index f352c35..1538fb4 100644
--- a/src/loadsave.cc
+++ b/src/loadsave.cc
@@ -834,6 +834,168 @@ int lsgSaveGame(int mode)
     return rc;
 }
 
+// Agent bridge: programmatic quicksave that bypasses the UI entirely.
+// Sets slot 0, writes a description, takes snapshot, and saves.
+int agentQuickSave(const char* description)
+{
+    ScopedGameMode gm(GameMode::kSaveGame);
+
+    _ls_error_code = 0;
+    _patches = settings.system.master_patches_path.c_str();
+    _slot_cursor = 0;
+
+    // Set up the slot description
+    memset(&_LSData[0], 0, sizeof(LoadSaveSlotData));
+    if (description != nullptr) {
+        strncpy(_LSData[0].description, description, LOAD_SAVE_DESCRIPTION_LENGTH - 1);
+        _LSData[0].description[LOAD_SAVE_DESCRIPTION_LENGTH - 1] = '\0';
+    } else {
+        strncpy(_LSData[0].description, "Agent Save", LOAD_SAVE_DESCRIPTION_LENGTH - 1);
+    }
+
+    if (!messageListInit(&gLoadSaveMessageList)) {
+        return -1;
+    }
+
+    char path[COMPAT_MAX_PATH];
+    snprintf(path, sizeof(path), "%s%s", asc_5186C8, "LSGAME.MSG");
+    if (!messageListLoad(&gLoadSaveMessageList, path)) {
+        return -1;
+    }
+
+    _snapshotBuf = nullptr;
+    int v6 = _QuickSnapShot();
+    if (v6 == 1) {
+        int v7 = lsgPerformSaveGame();
+        if (v7 != -1) {
+            v6 = v7;
+        }
+    }
+
+    if (_snapshotBuf != nullptr) {
+        internal_free(_snapshot);
+    }
+
+    gameMouseSetCursor(MOUSE_CURSOR_ARROW);
+
+    messageListFree(&gLoadSaveMessageList);
+
+    if (v6 != -1) {
+        _quick_done = true;
+        return 1;
+    }
+
+    return -1;
+}
+
+// Agent bridge: programmatic quickload that bypasses the UI.
+int agentQuickLoad()
+{
+    ScopedGameMode gm(GameMode::kLoadGame);
+
+    _ls_error_code = 0;
+    _patches = settings.system.master_patches_path.c_str();
+    _slot_cursor = 0;
+
+    // Check if the save file exists
+    snprintf(_gmpath, sizeof(_gmpath), "%s\\%s%.2d\\", "SAVEGAME", "SLOT", _slot_cursor + 1);
+    strcat(_gmpath, "SAVE.DAT");
+
+    _flptr = fileOpen(_gmpath, "rb");
+    if (_flptr == nullptr) {
+        return -1;
+    }
+    fileClose(_flptr);
+
+    if (!messageListInit(&gLoadSaveMessageList)) {
+        return -1;
+    }
+
+    char path[COMPAT_MAX_PATH];
+    snprintf(path, sizeof(path), "%s%s", asc_5186C8, "LSGAME.MSG");
+    if (!messageListLoad(&gLoadSaveMessageList, path)) {
+        return -1;
+    }
+
+    int rc = lsgLoadGameInSlot(_slot_cursor);
+
+    messageListFree(&gLoadSaveMessageList);
+
+    if (rc != -1) {
+        _quick_done = true;
+    }
+
+    return rc;
+}
+
+// Agent bridge: save to a specific slot (0-9 = SLOT01-SLOT10)
+int agentSaveToSlot(int slot, const char* description)
+{
+    if (slot < 0 || slot > 9) return -1;
+
+    ScopedGameMode gm(GameMode::kSaveGame);
+
+    _ls_error_code = 0;
+    _patches = settings.system.master_patches_path.c_str();
+    _slot_cursor = slot;
+
+    memset(&_LSData[slot], 0, sizeof(LoadSaveSlotData));
+    const char* desc = (description != nullptr) ? description : "Agent Save";
+    strncpy(_LSData[slot].description, desc, LOAD_SAVE_DESCRIPTION_LENGTH - 1);
+    _LSData[slot].description[LOAD_SAVE_DESCRIPTION_LENGTH - 1] = '\0';
+
+    if (!messageListInit(&gLoadSaveMessageList)) return -1;
+
+    char path[COMPAT_MAX_PATH];
+    snprintf(path, sizeof(path), "%s%s", asc_5186C8, "LSGAME.MSG");
+    if (!messageListLoad(&gLoadSaveMessageList, path)) return -1;
+
+    _snapshotBuf = nullptr;
+    int v6 = _QuickSnapShot();
+    if (v6 == 1) {
+        int v7 = lsgPerformSaveGame();
+        if (v7 != -1) v6 = v7;
+    }
+
+    if (_snapshotBuf != nullptr) internal_free(_snapshot);
+    gameMouseSetCursor(MOUSE_CURSOR_ARROW);
+    messageListFree(&gLoadSaveMessageList);
+
+    if (v6 != -1) { _quick_done = true; return 1; }
+    return -1;
+}
+
+// Agent bridge: load from a specific slot (0-9 = SLOT01-SLOT10)
+int agentLoadFromSlot(int slot)
+{
+    if (slot < 0 || slot > 9) return -1;
+
+    ScopedGameMode gm(GameMode::kLoadGame);
+
+    _ls_error_code = 0;
+    _patches = settings.system.master_patches_path.c_str();
+    _slot_cursor = slot;
+
+    snprintf(_gmpath, sizeof(_gmpath), "%s\\%s%.2d\\", "SAVEGAME", "SLOT", _slot_cursor + 1);
+    strcat(_gmpath, "SAVE.DAT");
+
+    _flptr = fileOpen(_gmpath, "rb");
+    if (_flptr == nullptr) return -1;
+    fileClose(_flptr);
+
+    if (!messageListInit(&gLoadSaveMessageList)) return -1;
+
+    char path[COMPAT_MAX_PATH];
+    snprintf(path, sizeof(path), "%s%s", asc_5186C8, "LSGAME.MSG");
+    if (!messageListLoad(&gLoadSaveMessageList, path)) return -1;
+
+    int rc = lsgLoadGameInSlot(_slot_cursor);
+    messageListFree(&gLoadSaveMessageList);
+
+    if (rc != -1) _quick_done = true;
+    return rc;
+}
+
 // 0x47C5B4
 static int _QuickSnapShot()
 {
diff --git a/src/loadsave.h b/src/loadsave.h
index 567548e..49835c3 100644
--- a/src/loadsave.h
+++ b/src/loadsave.h
@@ -23,6 +23,12 @@ void lsgInit();
 int MapDirErase(const char* path, const char* extension);
 int _MapDirEraseFile_(const char* a1, const char* a2);
 
+// Agent bridge: programmatic save/load bypassing the UI
+int agentQuickSave(const char* description = nullptr);
+int agentQuickLoad();
+int agentSaveToSlot(int slot, const char* description = nullptr);
+int agentLoadFromSlot(int slot);
+
 } // namespace fallout
 
 #endif /* LOAD_SAVE_GAME_H */
diff --git a/src/main.cc b/src/main.cc
index ee67a0a..bc46d11 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -3,6 +3,10 @@
 #include <limits.h>
 #include <string.h>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "art.h"
 #include "autorun.h"
 #include "character_selector.h"
@@ -129,6 +133,9 @@ int falloutMain(int argc, char** argv)
                     // SFALL: AfterNewGameStartHook.
                     sfall_gl_scr_exec_start_proc();
 
+#ifdef AGENT_BRIDGE
+                    agentBridgeSetContext(AGENT_CONTEXT_GAMEPLAY);
+#endif
                     mainLoop();
                     paletteFadeTo(gPaletteWhite);
 
@@ -139,7 +146,13 @@ int falloutMain(int argc, char** argv)
                     main_reset_system();
 
                     if (_main_show_death_scene != 0) {
+#ifdef AGENT_BRIDGE
+                        gAgentDeathScreenActive = true;
+#endif
                         showDeath();
+#ifdef AGENT_BRIDGE
+                        gAgentDeathScreenActive = false;
+#endif
                         _main_show_death_scene = 0;
                     }
                 }
@@ -158,12 +171,27 @@ int falloutMain(int argc, char** argv)
 
                     colorPaletteLoad("color.pal");
                     paletteFadeTo(_cmap);
-                    int loadGameRc = lsgLoadGame(LOAD_SAVE_MODE_FROM_MAIN_MENU);
+                    int loadGameRc;
+#ifdef AGENT_BRIDGE
+                    if (gAgentPendingLoadSlot >= 0) {
+                        // Agent requested direct slot load — bypass the dialog
+                        loadGameRc = agentLoadFromSlot(gAgentPendingLoadSlot);
+                        gAgentPendingLoadSlot = -1;
+                        if (loadGameRc == 0) loadGameRc = 1; // normalize: 1 = success
+                    } else {
+                        loadGameRc = lsgLoadGame(LOAD_SAVE_MODE_FROM_MAIN_MENU);
+                    }
+#else
+                    loadGameRc = lsgLoadGame(LOAD_SAVE_MODE_FROM_MAIN_MENU);
+#endif
                     if (loadGameRc == -1) {
                         debugPrint("\n ** Error running LoadGame()! **\n");
                     } else if (loadGameRc != 0) {
                         windowDestroy(win);
                         win = -1;
+#ifdef AGENT_BRIDGE
+                        agentBridgeSetContext(AGENT_CONTEXT_GAMEPLAY);
+#endif
                         mainLoop();
                     }
                     paletteFadeTo(gPaletteWhite);
@@ -178,7 +206,13 @@ int falloutMain(int argc, char** argv)
                     main_reset_system();
 
                     if (_main_show_death_scene != 0) {
+#ifdef AGENT_BRIDGE
+                        gAgentDeathScreenActive = true;
+#endif
                         showDeath();
+#ifdef AGENT_BRIDGE
+                        gAgentDeathScreenActive = false;
+#endif
                         _main_show_death_scene = 0;
                     }
                     mainMenuWindowInit();
diff --git a/src/mainmenu.cc b/src/mainmenu.cc
index bc0bf0a..4e4e67e 100644
--- a/src/mainmenu.cc
+++ b/src/mainmenu.cc
@@ -2,6 +2,10 @@
 
 #include <ctype.h>
 
+#ifdef AGENT_BRIDGE
+#include "agent_bridge.h"
+#endif
+
 #include "art.h"
 #include "color.h"
 #include "draw.h"
@@ -303,6 +307,10 @@ int mainMenuWindowHandleEvents()
 {
     _in_main_menu = true;
 
+#ifdef AGENT_BRIDGE
+    agentBridgeSetContext(AGENT_CONTEXT_MAIN_MENU);
+#endif
+
     bool oldCursorIsHidden = cursorIsHidden();
     if (oldCursorIsHidden) {
         mouseShowCursor();
@@ -316,6 +324,23 @@ int mainMenuWindowHandleEvents()
 
         int keyCode = inputGetInput();
 
+#ifdef AGENT_BRIDGE
+        // Check for agent-injected main menu actions
+        if (gAgentMainMenuAction != 0) {
+            switch (gAgentMainMenuAction) {
+            case 1: rc = MAIN_MENU_NEW_GAME; break;
+            case 2: rc = MAIN_MENU_LOAD_GAME; break;
+            case 3: rc = MAIN_MENU_OPTIONS; break;
+            case 4: rc = MAIN_MENU_EXIT; break;
+            }
+            gAgentMainMenuAction = 0;
+            if (rc != -1) {
+                main_menu_play_sound("nmselec1");
+                break;
+            }
+        }
+#endif
+
         for (int buttonIndex = 0; buttonIndex < MAIN_MENU_BUTTON_COUNT; buttonIndex++) {
             if (keyCode == gMainMenuButtonKeyBindings[buttonIndex] || keyCode == toupper(gMainMenuButtonKeyBindings[buttonIndex])) {
                 // NOTE: Uninline.
diff --git a/src/pipboy.cc b/src/pipboy.cc
index 9327894..e169130 100644
--- a/src/pipboy.cc
+++ b/src/pipboy.cc
@@ -2605,4 +2605,156 @@ static void holodiskFree()
     gHolodisksCount = 0;
 }
 
+// --- Agent bridge accessors ---
+
+int agentInitQuestData()
+{
+    if (gQuestsCount == 0) {
+        if (questInit() == -1) {
+            return -1;
+        }
+    }
+    if (gHolodisksCount == 0) {
+        holodiskInit();
+    }
+    return 0;
+}
+
+int agentGetQuestCount()
+{
+    return gQuestsCount;
+}
+
+int agentGetQuestLocationMsgId(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return -1;
+    return gQuestDescriptions[index].location;
+}
+
+int agentGetQuestDescriptionMsgId(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return -1;
+    return gQuestDescriptions[index].description;
+}
+
+int agentGetQuestGvar(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return -1;
+    return gQuestDescriptions[index].gvar;
+}
+
+int agentGetQuestDisplayThreshold(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return 0;
+    return gQuestDescriptions[index].displayThreshold;
+}
+
+int agentGetQuestCompletedThreshold(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return 0;
+    return gQuestDescriptions[index].completedThreshold;
+}
+
+const char* agentGetQuestDescriptionText(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return nullptr;
+    MessageListItem item;
+    item.num = gQuestDescriptions[index].description;
+    if (messageListGetItem(&gQuestsMessageList, &item)) {
+        return item.text;
+    }
+    return nullptr;
+}
+
+const char* agentGetQuestLocationText(int index)
+{
+    if (index < 0 || index >= gQuestsCount) return nullptr;
+    MessageListItem item;
+    item.num = gQuestDescriptions[index].location;
+    if (messageListGetItem(&gMapMessageList, &item)) {
+        return item.text;
+    }
+    return nullptr;
+}
+
+int agentGetHolodiskCount()
+{
+    return gHolodisksCount;
+}
+
+int agentGetHolodiskGvar(int index)
+{
+    if (index < 0 || index >= gHolodisksCount) return -1;
+    return gHolodiskDescriptions[index].gvar;
+}
+
+const char* agentGetHolodiskName(int index)
+{
+    if (index < 0 || index >= gHolodisksCount) return nullptr;
+    MessageListItem item;
+    item.num = gHolodiskDescriptions[index].name;
+    if (messageListGetItem(&gQuestsMessageList, &item)) {
+        return item.text;
+    }
+    return nullptr;
+}
+
+// Agent bridge: headless rest (no Pip-Boy UI, but same game logic)
+bool agentRest(int hours, int minutes)
+{
+    if (!_critter_can_obj_dude_rest())
+        return false;
+
+    _rest_time = 0;
+
+    int totalMinutes = hours * 60 + minutes;
+    unsigned int gameTime = gameTimeGetTime();
+
+    // Process minutes portion first (matching pipboyRest structure)
+    if (minutes > 0) {
+        unsigned int minuteEnd = gameTime + (unsigned int)minutes * 600;
+        unsigned int nextEvent = queueGetNextEventTime();
+        while (nextEvent > 0 && nextEvent <= minuteEnd) {
+            gameTimeSetTime(nextEvent + 1);
+            if (queueProcessEvents()) {
+                return true; // interrupted
+            }
+            nextEvent = queueGetNextEventTime();
+        }
+        gameTimeSetTime(minuteEnd);
+
+        if (_Check4Health(minutes)) {
+            _AddHealth();
+        }
+    }
+
+    // Process hours in 10-minute increments for event granularity
+    if (hours > 0) {
+        int hoursMinutes = hours * 60;
+        unsigned int hourStart = gameTime + (unsigned int)minutes * 600;
+
+        for (int elapsed = 0; elapsed < hoursMinutes; elapsed += 10) {
+            int step = (hoursMinutes - elapsed < 10) ? (hoursMinutes - elapsed) : 10;
+            unsigned int targetTime = hourStart + (unsigned int)(elapsed + step) * 600;
+
+            unsigned int nextEvent = queueGetNextEventTime();
+            while (nextEvent > 0 && nextEvent <= targetTime) {
+                gameTimeSetTime(nextEvent + 1);
+                if (queueProcessEvents()) {
+                    return true; // interrupted
+                }
+                nextEvent = queueGetNextEventTime();
+            }
+
+            gameTimeSetTime(targetTime);
+
+            if (_Check4Health(step)) {
+                _AddHealth();
+            }
+        }
+    }
+
+    return false; // not interrupted
+}
+
 } // namespace fallout
diff --git a/src/pipboy.h b/src/pipboy.h
index bd17f64..5ced60e 100644
--- a/src/pipboy.h
+++ b/src/pipboy.h
@@ -16,6 +16,24 @@ void pipboyReset();
 int pipboySave(File* stream);
 int pipboyLoad(File* stream);
 
+// Agent bridge: quest and holodisk data
+int agentInitQuestData();
+int agentGetQuestCount();
+int agentGetQuestLocationMsgId(int index);
+int agentGetQuestDescriptionMsgId(int index);
+int agentGetQuestGvar(int index);
+int agentGetQuestDisplayThreshold(int index);
+int agentGetQuestCompletedThreshold(int index);
+const char* agentGetQuestDescriptionText(int index);
+const char* agentGetQuestLocationText(int index);
+
+// Agent bridge: headless rest (no Pip-Boy UI)
+bool agentRest(int hours, int minutes);
+
+int agentGetHolodiskCount();
+int agentGetHolodiskGvar(int index);
+const char* agentGetHolodiskName(int index);
+
 } // namespace fallout
 
 #endif /* PIPBOY_H */
diff --git a/src/proto_instance.cc b/src/proto_instance.cc
index 02bb39d..9d0a032 100644
--- a/src/proto_instance.cc
+++ b/src/proto_instance.cc
@@ -1631,6 +1631,19 @@ static int _check_door_state(Object* door, Object* obj2)
             door->flags &= ~OBJECT_OPEN_DOOR;
         }
 
+        // Agent bridge: re-block co-located scenery/wall objects (Door Track, etc.)
+        // when door closes
+        Object* obj = objectFindFirstAtLocation(door->elevation, door->tile);
+        while (obj != nullptr) {
+            if (obj != door) {
+                int coType = FID_TYPE(obj->fid);
+                if (coType == OBJ_TYPE_SCENERY || coType == OBJ_TYPE_WALL) {
+                    obj->flags &= ~OBJECT_NO_BLOCK;
+                }
+            }
+            obj = objectFindNextAtLocation();
+        }
+
         _obj_rebuild_all_light();
         tileWindowRefresh();
 
@@ -1669,6 +1682,19 @@ static int _check_door_state(Object* door, Object* obj2)
             door->flags |= OBJECT_OPEN_DOOR;
         }
 
+        // Agent bridge: unblock co-located scenery/wall objects (Door Track, etc.)
+        // when door opens so pathfinding works through open doors
+        Object* obj = objectFindFirstAtLocation(door->elevation, door->tile);
+        while (obj != nullptr) {
+            if (obj != door) {
+                int coType = FID_TYPE(obj->fid);
+                if (coType == OBJ_TYPE_SCENERY || coType == OBJ_TYPE_WALL) {
+                    obj->flags |= OBJECT_NO_BLOCK;
+                }
+            }
+            obj = objectFindNextAtLocation();
+        }
+
         _obj_rebuild_all_light();
         tileWindowRefresh();
 
diff --git a/src/queue.cc b/src/queue.cc
index 9056904..4d932fa 100644
--- a/src/queue.cc
+++ b/src/queue.cc
@@ -486,6 +486,9 @@ static int _queue_do_explosion_(Object* explosive, bool animate)
     if (actionExplode(tile, elevation, minDamage, maxDamage, gDude, animate) == -2) {
         queueAddEvent(50, explosive, nullptr, EVENT_TYPE_EXPLOSION);
     } else {
+        // actionExplode already calls _combat_explode_scenery (which calls
+        // _scr_explode_scenery) via animation callback (animate=true) or
+        // directly (animate=false). No extra scenery call needed here.
         _obj_destroy(explosive);
     }
 
diff --git a/src/svga.cc b/src/svga.cc
index 8acca96..f2e8304 100644
--- a/src/svga.cc
+++ b/src/svga.cc
@@ -134,6 +134,16 @@ int _GNW95_init_mode_ex(int width, int height, int bpp)
                 }
             }
 
+            // WINDOW_SCALE: percentage-based window scaling (e.g. 125 = 1.25x)
+            // Keeps game resolution unchanged, just makes the window bigger.
+            // Overrides SCALE_2X if set.
+            int windowScalePct;
+            if (configGetInt(&resolutionConfig, "MAIN", "WINDOW_SCALE", &windowScalePct)) {
+                if (windowScalePct >= 100 && windowScalePct <= 400) {
+                    scale = -windowScalePct; // negative = percentage mode
+                }
+            }
+
             configGetBool(&resolutionConfig, "IFACE", "IFACE_BAR_MODE", &gInterfaceBarMode);
             configGetInt(&resolutionConfig, "IFACE", "IFACE_BAR_WIDTH", &gInterfaceBarWidth);
             configGetInt(&resolutionConfig, "IFACE", "IFACE_BAR_SIDE_ART", &gInterfaceSidePanelsImageId);
@@ -181,7 +191,36 @@ int _GNW95_init_window(int width, int height, bool fullscreen, int scale)
             windowFlags |= SDL_WINDOW_FULLSCREEN;
         }
 
-        gSdlWindow = SDL_CreateWindow(gProgramWindowTitle, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width * scale, height * scale, windowFlags);
+        // Read optional window position from f2_res.ini
+        int windowX = SDL_WINDOWPOS_UNDEFINED;
+        int windowY = SDL_WINDOWPOS_UNDEFINED;
+        {
+            Config posConfig;
+            if (configInit(&posConfig)) {
+                if (configRead(&posConfig, "f2_res.ini", false)) {
+                    int posVal;
+                    if (configGetInt(&posConfig, "MAIN", "WINDOW_X", &posVal)) {
+                        windowX = posVal;
+                    }
+                    if (configGetInt(&posConfig, "MAIN", "WINDOW_Y", &posVal)) {
+                        windowY = posVal;
+                    }
+                }
+                configFree(&posConfig);
+            }
+        }
+
+        int windowWidth, windowHeight;
+        if (scale < 0) {
+            // Negative scale = percentage mode (e.g. -125 = 125%)
+            int pct = -scale;
+            windowWidth = width * pct / 100;
+            windowHeight = height * pct / 100;
+        } else {
+            windowWidth = width * scale;
+            windowHeight = height * scale;
+        }
+        gSdlWindow = SDL_CreateWindow(gProgramWindowTitle, windowX, windowY, windowWidth, windowHeight, windowFlags);
         if (gSdlWindow == nullptr) {
             return -1;
         }
diff --git a/src/text_object.cc b/src/text_object.cc
index 5bc000a..dcb2ff1 100644
--- a/src/text_object.cc
+++ b/src/text_object.cc
@@ -184,7 +184,7 @@ int textObjectAdd(Object* object, char* string, int font, int color, int outline
 
     short beginnings[WORD_WRAP_MAX_COUNT];
     short count;
-    if (wordWrap(string, 200, beginnings, &count) != 0) {
+    if (wordWrap(string, 350, beginnings, &count) != 0) {
         fontSetCurrent(oldFont);
         return -1;
     }
@@ -295,6 +295,12 @@ void textObjectsRenderInRect(Rect* rect)
 
     for (int index = 0; index < gTextObjectsCount; index++) {
         TextObject* textObject = gTextObjects[index];
+
+        // Follow the owner if it has moved to a new tile
+        if (textObject->owner != nullptr && (textObject->flags & TEXT_OBJECT_UNBOUNDED) == 0) {
+            textObject->tile = textObject->owner->tile;
+        }
+
         tileToScreenXY(textObject->tile, &(textObject->x), &(textObject->y), gElevation);
         textObject->x += textObject->sx;
         textObject->y += textObject->sy;
@@ -334,6 +340,11 @@ static void textObjectsTicker()
     for (int index = 0; index < gTextObjectsCount; index++) {
         TextObject* textObject = gTextObjects[index];
 
+        // Follow the owner if it has moved to a new tile
+        if (textObject->owner != nullptr && (textObject->flags & TEXT_OBJECT_UNBOUNDED) == 0) {
+            textObject->tile = textObject->owner->tile;
+        }
+
         unsigned int delay = gTextObjectsLineDelay * textObject->linesCount + gTextObjectsBaseDelay;
         if ((textObject->flags & TEXT_OBJECT_MARKED_FOR_REMOVAL) != 0 || (getTicksBetween(_get_bk_time(), textObject->time) > delay)) {
             tileToScreenXY(textObject->tile, &(textObject->x), &(textObject->y), gElevation);
diff --git a/src/window_manager.cc b/src/window_manager.cc
index 9381222..cf1de46 100644
--- a/src/window_manager.cc
+++ b/src/window_manager.cc
@@ -27,7 +27,7 @@ namespace fallout {
 #define BUTTON_GROUP_LIST_CAPACITY (64)
 
 static void windowFree(int win);
-static void _win_buffering(bool a1);
+// _win_buffering declared in window_manager.h
 static void _win_move(int win_index, int x, int y);
 static void _win_clip(Window* window, RectListNode** rect, unsigned char* a3);
 static void win_drag(int win);
@@ -1105,6 +1105,31 @@ void _refresh_all(Rect* rect, unsigned char* a2)
     }
 }
 
+// Composite all visible windows at the given rect into a caller-provided buffer.
+// Buffer must be (rect width * rect height) bytes. Uses the a3 path of
+// _GNW_win_refresh which blits opaquely into the buffer (no _scr_blit).
+void windowCompositeToBuffer(Rect* rect, unsigned char* buffer)
+{
+    if (!gWindowSystemInitialized || buffer == nullptr || rect == nullptr)
+        return;
+
+    int width = rect->right - rect->left + 1;
+    int height = rect->bottom - rect->top + 1;
+    if (width <= 0 || height <= 0)
+        return;
+
+    // Fill with background color first
+    bufferFill(buffer, width, height, width, _bk_color);
+
+    _doing_refresh_all = 1;
+
+    for (int index = 0; index < gWindowsLength; index++) {
+        _GNW_win_refresh(gWindows[index], rect, buffer);
+    }
+
+    _doing_refresh_all = 0;
+}
+
 // 0x4D7888
 Window* windowGetWindow(int win)
 {
diff --git a/src/window_manager.h b/src/window_manager.h
index 2f76563..3470941 100644
--- a/src/window_manager.h
+++ b/src/window_manager.h
@@ -197,6 +197,8 @@ int buttonDisable(int btn);
 int _win_set_button_rest_state(int btn, bool checked, int flags);
 int _win_group_radio_buttons(int buttonCount, int* btns);
 int _win_button_press_and_release(int btn);
+void _win_buffering(bool buffering);
+void windowCompositeToBuffer(Rect* rect, unsigned char* buffer);
 
 } // namespace fallout
 
diff --git a/src/worldmap.cc b/src/worldmap.cc
index 2929cc0..49e8304 100644
--- a/src/worldmap.cc
+++ b/src/worldmap.cc
@@ -818,6 +818,13 @@ static int wmMaxEncBaseTypes;
 static int wmMaxEncounterInfoTables;
 
 static bool gTownMapHotkeysFix;
+
+// Agent bridge: pending map load request from the ticker (within worldmap loop)
+static int gAgentPendingMapLoad = -1;
+static int gAgentPendingMapElevation = 0;
+static int gAgentPendingMapTile = -1;
+static int gAgentPendingMapRotation = 0;
+
 static double gGameTimeIncRemainder = 0.0;
 static FrmImage _backgroundFrmImage;
 static FrmImage _townFrmImage;
@@ -3000,6 +3007,15 @@ static int wmWorldMapFunc(int a1)
         // SFALL: WorldmapLoopHook.
         sfall_gl_scr_process_worldmap();
 
+        // Agent bridge: check for pending map load request from ticker
+        if (gAgentPendingMapLoad >= 0) {
+            map = gAgentPendingMapLoad;
+            mapSetEnteringLocation(gAgentPendingMapElevation, gAgentPendingMapTile, gAgentPendingMapRotation);
+            gAgentPendingMapLoad = -1;
+            wmFadeOut();
+            mapLoadById(map);
+        }
+
         unsigned int now = getTicks();
 
         int mouseX;
@@ -6671,4 +6687,100 @@ void wmForceEncounter(int map, unsigned int flags)
     }
 }
 
+// --- Agent bridge accessors ---
+
+int agentWmGetAreaCount()
+{
+    return wmMaxAreaNum;
+}
+
+int agentWmGetAreaInfo(int areaIdx, char* nameOut, int nameSize, int* xOut, int* yOut, int* stateOut, int* sizeOut)
+{
+    if (areaIdx < 0 || areaIdx >= wmMaxAreaNum || wmAreaInfoList == nullptr)
+        return -1;
+
+    CityInfo* city = &wmAreaInfoList[areaIdx];
+    if (nameOut != nullptr && nameSize > 0) {
+        strncpy(nameOut, city->name, nameSize - 1);
+        nameOut[nameSize - 1] = '\0';
+    }
+    if (xOut) *xOut = city->x;
+    if (yOut) *yOut = city->y;
+    if (stateOut) *stateOut = city->state;
+    if (sizeOut) *sizeOut = city->size;
+    return 0;
+}
+
+int agentWmGetAreaEntranceCount(int areaIdx)
+{
+    if (areaIdx < 0 || areaIdx >= wmMaxAreaNum || wmAreaInfoList == nullptr)
+        return 0;
+    return wmAreaInfoList[areaIdx].entrancesLength;
+}
+
+int agentWmGetAreaEntrance(int areaIdx, int entranceIdx, int* mapOut, int* elevOut, int* tileOut, int* stateOut)
+{
+    if (areaIdx < 0 || areaIdx >= wmMaxAreaNum || wmAreaInfoList == nullptr)
+        return -1;
+    CityInfo* city = &wmAreaInfoList[areaIdx];
+    if (entranceIdx < 0 || entranceIdx >= city->entrancesLength)
+        return -1;
+
+    EntranceInfo* ent = &city->entrances[entranceIdx];
+    if (mapOut) *mapOut = ent->map;
+    if (elevOut) *elevOut = ent->elevation;
+    if (tileOut) *tileOut = ent->tile;
+    if (stateOut) *stateOut = ent->state;
+    return 0;
+}
+
+bool agentWmIsWalking()
+{
+    return wmGenData.isWalking;
+}
+
+int agentWmGetWalkDestination(int* xOut, int* yOut)
+{
+    if (xOut) *xOut = wmGenData.walkDestinationX;
+    if (yOut) *yOut = wmGenData.walkDestinationY;
+    return 0;
+}
+
+bool agentWmIsInCar()
+{
+    return wmGenData.isInCar;
+}
+
+int agentWmGetCarFuel()
+{
+    return wmGenData.carFuel;
+}
+
+void agentWmRequestMapLoad(int mapIdx, int elevation, int tile, int rotation)
+{
+    gAgentPendingMapLoad = mapIdx;
+    gAgentPendingMapElevation = elevation;
+    gAgentPendingMapTile = tile;
+    gAgentPendingMapRotation = rotation;
+}
+
+int agentWmStartWalkingToArea(int areaId)
+{
+    if (areaId < 0 || areaId >= wmMaxAreaNum || wmAreaInfoList == nullptr)
+        return -1;
+    if (wmGenData.currentAreaId == areaId)
+        return -3; // already there
+
+    CityInfo* city = &(wmAreaInfoList[areaId]);
+    CitySizeDescription* citySizeDescription = &(wmSphereData[city->size]);
+
+    // Replicate the same coordinate calculation used by Ctrl+F1..F7 hotkeys
+    int destX = city->x + citySizeDescription->frmImage.getWidth() / 2 - WM_VIEW_X;
+    int destY = city->y + citySizeDescription->frmImage.getHeight() / 2 - WM_VIEW_Y;
+
+    wmPartyInitWalking(destX, destY);
+    wmGenData.mousePressed = false;
+    return 0;
+}
+
 } // namespace fallout
diff --git a/src/worldmap.h b/src/worldmap.h
index 20ea1c2..4131ff5 100644
--- a/src/worldmap.h
+++ b/src/worldmap.h
@@ -287,6 +287,22 @@ void wmSetPartyWorldPos(int x, int y);
 void wmCarSetCurrentArea(int area);
 void wmForceEncounter(int map, unsigned int flags);
 
+// Agent bridge: request map load from within worldmap loop
+void agentWmRequestMapLoad(int mapIdx, int elevation, int tile, int rotation);
+
+// Agent bridge: initiate walking to an area (player-like travel)
+int agentWmStartWalkingToArea(int areaId);
+
+// Agent bridge accessors for world map data
+int agentWmGetAreaCount();
+int agentWmGetAreaInfo(int areaIdx, char* nameOut, int nameSize, int* xOut, int* yOut, int* stateOut, int* sizeOut);
+int agentWmGetAreaEntranceCount(int areaIdx);
+int agentWmGetAreaEntrance(int areaIdx, int entranceIdx, int* mapOut, int* elevOut, int* tileOut, int* stateOut);
+bool agentWmIsWalking();
+int agentWmGetWalkDestination(int* xOut, int* yOut);
+bool agentWmIsInCar();
+int agentWmGetCarFuel();
+
 } // namespace fallout
 
 #endif /* WORLD_MAP_H */
